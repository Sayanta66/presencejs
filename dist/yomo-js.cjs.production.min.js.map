{"version":3,"file":"yomo-js.cjs.production.min.js","sources":["../node_modules/regenerator-runtime/runtime.js","../src/WasmExec.ts","../src/YoMoClient.ts"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n//\n// This file has been modified for use by the TinyGo compiler.\n\n// Map multiple JavaScript environments to a single common API,\n// preferring web standards over Node.js API.\n//\n// Environments considered:\n// - Browsers\n// - Node.js\n// - Electron\n// - Parcel\n\n// @ts-nocheck\nif (typeof global !== 'undefined') {\n    // global already exists\n} else if (typeof window !== 'undefined') {\n    window.global = window;\n} else if (typeof self !== 'undefined') {\n    self.global = self;\n} else {\n    throw new Error(\n        'cannot export Go (neither global, window nor self is defined)'\n    );\n}\n\nif (!global.require && typeof require !== 'undefined') {\n    global.require = require;\n}\n\nif (!global.fs && global.require) {\n    global.fs = require('fs');\n}\n\nconst enosys = () => {\n    const err = new Error('not implemented');\n    err.code = 'ENOSYS';\n    return err;\n};\n\nif (!global.fs) {\n    let outputBuf = '';\n    global.fs = {\n        constants: {\n            O_WRONLY: -1,\n            O_RDWR: -1,\n            O_CREAT: -1,\n            O_TRUNC: -1,\n            O_APPEND: -1,\n            O_EXCL: -1,\n        }, // unused\n        writeSync(fd, buf) {\n            outputBuf += decoder.decode(buf);\n            const nl = outputBuf.lastIndexOf('\\n');\n            if (nl != -1) {\n                console.log(outputBuf.substr(0, nl));\n                outputBuf = outputBuf.substr(nl + 1);\n            }\n            return buf.length;\n        },\n        write(fd, buf, offset, length, position, callback) {\n            if (offset !== 0 || length !== buf.length || position !== null) {\n                callback(enosys());\n                return;\n            }\n            const n = this.writeSync(fd, buf);\n            callback(null, n);\n        },\n        chmod(path, mode, callback) {\n            callback(enosys());\n        },\n        chown(path, uid, gid, callback) {\n            callback(enosys());\n        },\n        close(fd, callback) {\n            callback(enosys());\n        },\n        fchmod(fd, mode, callback) {\n            callback(enosys());\n        },\n        fchown(fd, uid, gid, callback) {\n            callback(enosys());\n        },\n        fstat(fd, callback) {\n            callback(enosys());\n        },\n        fsync(fd, callback) {\n            callback(null);\n        },\n        ftruncate(fd, length, callback) {\n            callback(enosys());\n        },\n        lchown(path, uid, gid, callback) {\n            callback(enosys());\n        },\n        link(path, link, callback) {\n            callback(enosys());\n        },\n        lstat(path, callback) {\n            callback(enosys());\n        },\n        mkdir(path, perm, callback) {\n            callback(enosys());\n        },\n        open(path, flags, mode, callback) {\n            callback(enosys());\n        },\n        read(fd, buffer, offset, length, position, callback) {\n            callback(enosys());\n        },\n        readdir(path, callback) {\n            callback(enosys());\n        },\n        readlink(path, callback) {\n            callback(enosys());\n        },\n        rename(from, to, callback) {\n            callback(enosys());\n        },\n        rmdir(path, callback) {\n            callback(enosys());\n        },\n        stat(path, callback) {\n            callback(enosys());\n        },\n        symlink(path, link, callback) {\n            callback(enosys());\n        },\n        truncate(path, length, callback) {\n            callback(enosys());\n        },\n        unlink(path, callback) {\n            callback(enosys());\n        },\n        utimes(path, atime, mtime, callback) {\n            callback(enosys());\n        },\n    };\n}\n\nif (!global.process) {\n    global.process = {\n        getuid() {\n            return -1;\n        },\n        getgid() {\n            return -1;\n        },\n        geteuid() {\n            return -1;\n        },\n        getegid() {\n            return -1;\n        },\n        getgroups() {\n            throw enosys();\n        },\n        pid: -1,\n        ppid: -1,\n        umask() {\n            throw enosys();\n        },\n        cwd() {\n            throw enosys();\n        },\n        chdir() {\n            throw enosys();\n        },\n    };\n}\n\nif (!global.crypto) {\n    const nodeCrypto = require('crypto');\n    global.crypto = {\n        getRandomValues(b) {\n            nodeCrypto.randomFillSync(b);\n        },\n    };\n}\n\nif (!global.performance) {\n    global.performance = {\n        now() {\n            const [sec, nsec] = process.hrtime();\n            return sec * 1000 + nsec / 1000000;\n        },\n    };\n}\n\nif (!global.TextEncoder) {\n    global.TextEncoder = require('util').TextEncoder;\n}\n\nif (!global.TextDecoder) {\n    global.TextDecoder = require('util').TextDecoder;\n}\n\n// End of polyfills for common API.fglobal\n\nconst encoder = new TextEncoder('utf-8');\nconst decoder = new TextDecoder('utf-8');\nvar logLine = [];\n\nglobal.Go = class {\n    constructor() {\n        this._callbackTimeouts = new Map();\n        this._nextCallbackTimeoutID = 1;\n\n        const mem = () => {\n            // The buffer may change when requesting more memory.\n            return new DataView(this._inst.exports.memory.buffer);\n        };\n\n        const setInt64 = (addr, v) => {\n            mem().setUint32(addr + 0, v, true);\n            mem().setUint32(addr + 4, Math.floor(v / 4294967296), true);\n        };\n\n        const getInt64 = addr => {\n            const low = mem().getUint32(addr + 0, true);\n            const high = mem().getInt32(addr + 4, true);\n            return low + high * 4294967296;\n        };\n\n        const loadValue = addr => {\n            const f = mem().getFloat64(addr, true);\n            if (f === 0) {\n                return undefined;\n            }\n            if (!isNaN(f)) {\n                return f;\n            }\n\n            const id = mem().getUint32(addr, true);\n            return this._values[id];\n        };\n\n        const storeValue = (addr, v) => {\n            const nanHead = 0x7ff80000;\n\n            if (typeof v === 'number') {\n                if (isNaN(v)) {\n                    mem().setUint32(addr + 4, nanHead, true);\n                    mem().setUint32(addr, 0, true);\n                    return;\n                }\n                if (v === 0) {\n                    mem().setUint32(addr + 4, nanHead, true);\n                    mem().setUint32(addr, 1, true);\n                    return;\n                }\n                mem().setFloat64(addr, v, true);\n                return;\n            }\n\n            switch (v) {\n                case undefined:\n                    mem().setFloat64(addr, 0, true);\n                    return;\n                case null:\n                    mem().setUint32(addr + 4, nanHead, true);\n                    mem().setUint32(addr, 2, true);\n                    return;\n                case true:\n                    mem().setUint32(addr + 4, nanHead, true);\n                    mem().setUint32(addr, 3, true);\n                    return;\n                case false:\n                    mem().setUint32(addr + 4, nanHead, true);\n                    mem().setUint32(addr, 4, true);\n                    return;\n            }\n\n            let id = this._ids.get(v);\n            if (id === undefined) {\n                id = this._idPool.pop();\n                if (id === undefined) {\n                    id = this._values.length;\n                }\n                this._values[id] = v;\n                this._goRefCounts[id] = 0;\n                this._ids.set(v, id);\n            }\n            this._goRefCounts[id]++;\n            let typeFlag = 1;\n            switch (typeof v) {\n                case 'string':\n                    typeFlag = 2;\n                    break;\n                case 'symbol':\n                    typeFlag = 3;\n                    break;\n                case 'function':\n                    typeFlag = 4;\n                    break;\n            }\n            mem().setUint32(addr + 4, nanHead | typeFlag, true);\n            mem().setUint32(addr, id, true);\n        };\n\n        const loadSlice = (array, len, cap) => {\n            return new Uint8Array(this._inst.exports.memory.buffer, array, len);\n        };\n\n        const loadSliceOfValues = (array, len, cap) => {\n            const a = new Array(len);\n            for (let i = 0; i < len; i++) {\n                a[i] = loadValue(array + i * 8);\n            }\n            return a;\n        };\n\n        const loadString = (ptr, len) => {\n            return decoder.decode(\n                new DataView(this._inst.exports.memory.buffer, ptr, len)\n            );\n        };\n\n        const timeOrigin = Date.now() - performance.now();\n        this.importObject = {\n            wasi_snapshot_preview1: {\n                // https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md#fd_write\n                fd_write: function(fd, iovs_ptr, iovs_len, nwritten_ptr) {\n                    let nwritten = 0;\n                    if (fd == 1) {\n                        for (let iovs_i = 0; iovs_i < iovs_len; iovs_i++) {\n                            let iov_ptr = iovs_ptr + iovs_i * 8; // assuming wasm32\n                            let ptr = mem().getUint32(iov_ptr + 0, true);\n                            let len = mem().getUint32(iov_ptr + 4, true);\n                            nwritten += len;\n                            for (let i = 0; i < len; i++) {\n                                let c = mem().getUint8(ptr + i);\n                                if (c == 13) {\n                                    // CR\n                                    // ignore\n                                } else if (c == 10) {\n                                    // LF\n                                    // write line\n                                    let line = decoder.decode(\n                                        new Uint8Array(logLine)\n                                    );\n                                    logLine = [];\n                                    console.log(line);\n                                } else {\n                                    logLine.push(c);\n                                }\n                            }\n                        }\n                    } else {\n                        console.error('invalid file descriptor:', fd);\n                    }\n                    mem().setUint32(nwritten_ptr, nwritten, true);\n                    return 0;\n                },\n                fd_close: () => 0, // dummy\n                fd_fdstat_get: () => 0, // dummy\n                fd_seek: () => 0, // dummy\n                proc_exit: code => {\n                    if (global.process) {\n                        // Node.js\n                        process.exit(code);\n                    } else {\n                        // Can't exit in a browser.\n                        throw 'trying to exit with code ' + code;\n                    }\n                },\n                random_get: (bufPtr, bufLen) => {\n                    crypto.getRandomValues(loadSlice(bufPtr, bufLen));\n                    return 0;\n                },\n            },\n            env: {\n                // func ticks() float64\n                'runtime.ticks': () => {\n                    return timeOrigin + performance.now();\n                },\n\n                // func sleepTicks(timeout float64)\n                'runtime.sleepTicks': timeout => {\n                    // Do not sleep, only reactivate scheduler after the given timeout.\n                    setTimeout(this._inst.exports.go_scheduler, timeout);\n                },\n\n                // func finalizeRef(v ref)\n                'syscall/js.finalizeRef': sp => {\n                    // Note: TinyGo does not support finalizers so this should never be\n                    // called.\n                    console.error('syscall/js.finalizeRef not implemented');\n                },\n\n                // func stringVal(value string) ref\n                'syscall/js.stringVal': (ret_ptr, value_ptr, value_len) => {\n                    const s = loadString(value_ptr, value_len);\n                    storeValue(ret_ptr, s);\n                },\n\n                // func valueGet(v ref, p string) ref\n                'syscall/js.valueGet': (retval, v_addr, p_ptr, p_len) => {\n                    let prop = loadString(p_ptr, p_len);\n                    let value = loadValue(v_addr);\n                    let result = Reflect.get(value, prop);\n                    storeValue(retval, result);\n                },\n\n                // func valueSet(v ref, p string, x ref)\n                'syscall/js.valueSet': (v_addr, p_ptr, p_len, x_addr) => {\n                    const v = loadValue(v_addr);\n                    const p = loadString(p_ptr, p_len);\n                    const x = loadValue(x_addr);\n                    Reflect.set(v, p, x);\n                },\n\n                // func valueDelete(v ref, p string)\n                'syscall/js.valueDelete': (v_addr, p_ptr, p_len) => {\n                    const v = loadValue(v_addr);\n                    const p = loadString(p_ptr, p_len);\n                    Reflect.deleteProperty(v, p);\n                },\n\n                // func valueIndex(v ref, i int) ref\n                'syscall/js.valueIndex': (ret_addr, v_addr, i) => {\n                    storeValue(ret_addr, Reflect.get(loadValue(v_addr), i));\n                },\n\n                // valueSetIndex(v ref, i int, x ref)\n                'syscall/js.valueSetIndex': (v_addr, i, x_addr) => {\n                    Reflect.set(loadValue(v_addr), i, loadValue(x_addr));\n                },\n\n                // func valueCall(v ref, m string, args []ref) (ref, bool)\n                'syscall/js.valueCall': (\n                    ret_addr,\n                    v_addr,\n                    m_ptr,\n                    m_len,\n                    args_ptr,\n                    args_len,\n                    args_cap\n                ) => {\n                    const v = loadValue(v_addr);\n                    const name = loadString(m_ptr, m_len);\n                    const args = loadSliceOfValues(\n                        args_ptr,\n                        args_len,\n                        args_cap\n                    );\n                    try {\n                        const m = Reflect.get(v, name);\n                        storeValue(ret_addr, Reflect.apply(m, v, args));\n                        mem().setUint8(ret_addr + 8, 1);\n                    } catch (err) {\n                        storeValue(ret_addr, err);\n                        mem().setUint8(ret_addr + 8, 0);\n                    }\n                },\n\n                // func valueInvoke(v ref, args []ref) (ref, bool)\n                'syscall/js.valueInvoke': (\n                    ret_addr,\n                    v_addr,\n                    args_ptr,\n                    args_len,\n                    args_cap\n                ) => {\n                    try {\n                        const v = loadValue(v_addr);\n                        const args = loadSliceOfValues(\n                            args_ptr,\n                            args_len,\n                            args_cap\n                        );\n                        storeValue(ret_addr, Reflect.apply(v, undefined, args));\n                        mem().setUint8(ret_addr + 8, 1);\n                    } catch (err) {\n                        storeValue(ret_addr, err);\n                        mem().setUint8(ret_addr + 8, 0);\n                    }\n                },\n\n                // func valueNew(v ref, args []ref) (ref, bool)\n                'syscall/js.valueNew': (\n                    ret_addr,\n                    v_addr,\n                    args_ptr,\n                    args_len,\n                    args_cap\n                ) => {\n                    const v = loadValue(v_addr);\n                    const args = loadSliceOfValues(\n                        args_ptr,\n                        args_len,\n                        args_cap\n                    );\n                    try {\n                        storeValue(ret_addr, Reflect.construct(v, args));\n                        mem().setUint8(ret_addr + 8, 1);\n                    } catch (err) {\n                        storeValue(ret_addr, err);\n                        mem().setUint8(ret_addr + 8, 0);\n                    }\n                },\n\n                // func valueLength(v ref) int\n                'syscall/js.valueLength': v_addr => {\n                    return loadValue(v_addr).length;\n                },\n\n                // valuePrepareString(v ref) (ref, int)\n                'syscall/js.valuePrepareString': (ret_addr, v_addr) => {\n                    const s = String(loadValue(v_addr));\n                    const str = encoder.encode(s);\n                    storeValue(ret_addr, str);\n                    setInt64(ret_addr + 8, str.length);\n                },\n\n                // valueLoadString(v ref, b []byte)\n                'syscall/js.valueLoadString': (\n                    v_addr,\n                    slice_ptr,\n                    slice_len,\n                    slice_cap\n                ) => {\n                    const str = loadValue(v_addr);\n                    loadSlice(slice_ptr, slice_len, slice_cap).set(str);\n                },\n\n                // func valueInstanceOf(v ref, t ref) bool\n                'syscall/js.valueInstanceOf': (v_addr, t_addr) => {\n                    return loadValue(v_addr) instanceof loadValue(t_addr);\n                },\n\n                // func copyBytesToGo(dst []byte, src ref) (int, bool)\n                'syscall/js.copyBytesToGo': (\n                    ret_addr,\n                    dest_addr,\n                    dest_len,\n                    dest_cap,\n                    source_addr\n                ) => {\n                    let num_bytes_copied_addr = ret_addr;\n                    let returned_status_addr = ret_addr + 4; // Address of returned boolean status variable\n\n                    const dst = loadSlice(dest_addr, dest_len);\n                    const src = loadValue(source_addr);\n                    if (!(src instanceof Uint8Array)) {\n                        mem().setUint8(returned_status_addr, 0); // Return \"not ok\" status\n                        return;\n                    }\n                    const toCopy = src.subarray(0, dst.length);\n                    dst.set(toCopy);\n                    setInt64(num_bytes_copied_addr, toCopy.length);\n                    mem().setUint8(returned_status_addr, 1); // Return \"ok\" status\n                },\n\n                // copyBytesToJS(dst ref, src []byte) (int, bool)\n                // Originally copied from upstream Go project, then modified:\n                //   https://github.com/golang/go/blob/3f995c3f3b43033013013e6c7ccc93a9b1411ca9/misc/wasm/wasm_exec.js#L404-L416\n                'syscall/js.copyBytesToJS': (\n                    ret_addr,\n                    dest_addr,\n                    source_addr,\n                    source_len,\n                    source_cap\n                ) => {\n                    let num_bytes_copied_addr = ret_addr;\n                    let returned_status_addr = ret_addr + 4; // Address of returned boolean status variable\n\n                    const dst = loadValue(dest_addr);\n                    const src = loadSlice(source_addr, source_len);\n                    if (!(dst instanceof Uint8Array)) {\n                        mem().setUint8(returned_status_addr, 0); // Return \"not ok\" status\n                        return;\n                    }\n                    const toCopy = src.subarray(0, dst.length);\n                    dst.set(toCopy);\n                    setInt64(num_bytes_copied_addr, toCopy.length);\n                    mem().setUint8(returned_status_addr, 1); // Return \"ok\" status\n                },\n            },\n        };\n    }\n\n    async run(instance) {\n        this._inst = instance;\n        this._values = [\n            // JS values that Go currently has references to, indexed by reference id\n            NaN,\n            0,\n            null,\n            true,\n            false,\n            global,\n            this,\n        ];\n        this._goRefCounts = []; // number of references that Go has to a JS value, indexed by reference id\n        this._ids = new Map(); // mapping from JS values to reference ids\n        this._idPool = []; // unused ids that have been garbage collected\n        this.exited = false; // whether the Go program has exited\n\n        const mem = new DataView(this._inst.exports.memory.buffer);\n\n        while (true) {\n            const callbackPromise = new Promise(resolve => {\n                this._resolveCallbackPromise = () => {\n                    if (this.exited) {\n                        throw new Error(\n                            'bad callback: Go program has already exited'\n                        );\n                    }\n                    setTimeout(resolve, 0); // make sure it is asynchronous\n                };\n            });\n            this._inst.exports._start();\n            if (this.exited) {\n                break;\n            }\n            await callbackPromise;\n        }\n    }\n\n    _resume() {\n        if (this.exited) {\n            throw new Error('Go program has already exited');\n        }\n        this._inst.exports.resume();\n        if (this.exited) {\n            this._resolveExitPromise();\n        }\n    }\n\n    _makeFuncWrapper(id) {\n        const go = this;\n        return function() {\n            const event = { id: id, this: this, args: arguments };\n            go._pendingEvent = event;\n            go._resume();\n            return event.result;\n        };\n    }\n};\n\nif (\n    global.require &&\n    global.require.main === module &&\n    global.process &&\n    global.process.versions &&\n    !global.process.versions.electron\n) {\n    if (process.argv.length != 3) {\n        console.error('usage: go_js_wasm_exec [wasm binary] [arguments]');\n        process.exit(1);\n    }\n\n    const go = new Go();\n    WebAssembly.instantiate(fs.readFileSync(process.argv[2]), go.importObject)\n        .then(result => {\n            return go.run(result.instance);\n        })\n        .catch(err => {\n            console.error(err);\n            process.exit(1);\n        });\n}\n\nexport default global.Go;\n","import { interval, Observable, Subject, Subscription } from 'rxjs';\nimport { distinctUntilChanged, filter, takeWhile } from 'rxjs/operators';\nimport { WebSocketSubject } from 'rxjs/webSocket';\nimport Go from './WasmExec';\n\ntype WebSocketMessage = {\n    event: string;\n    data: string | object;\n};\n\nexport type YoMoClientConnectionStatusObserver = Observable<boolean>;\n\nexport interface YoMoClientOption {\n    // The reconnection interval value.\n    reconnectInterval?: number;\n    // The reconnection attempts value.\n    reconnectAttempts?: number;\n}\n\nexport default class YoMoClient<T> extends Subject<T> {\n    private socket$: WebSocketSubject<WebSocketMessage> | undefined;\n    private socketSubscription: Subscription | undefined;\n\n    // Reconnection stream\n    private reconnectionObservable: Observable<number> | undefined;\n    private reconnectionSubscription: Subscription | undefined;\n    private reconnectInterval: number;\n    private readonly reconnectAttempts: number;\n\n    private connectionStatus$: Subject<boolean>;\n\n    private wasmLoaded: boolean;\n\n    constructor(url: string, option: YoMoClientOption) {\n        if (!isWSProtocol(getProtocol(url))) {\n            throw new Error(\n                `${url} -> The URL's scheme must be either 'ws' or 'wss'`\n            );\n        }\n\n        super();\n\n        this.reconnectInterval = option.reconnectInterval || 5000;\n        this.reconnectAttempts = option.reconnectAttempts || 5;\n        this.connectionStatus$ = new Subject<boolean>();\n        this.connectionStatus$.subscribe({\n            next: isConnected => {\n                if (\n                    !this.reconnectionObservable &&\n                    typeof isConnected === 'boolean' &&\n                    !isConnected\n                ) {\n                    this.reconnect(url, option);\n                }\n            },\n        });\n\n        this.wasmLoaded = false;\n\n        this.connect(url, option);\n    }\n\n    /**\n     * return connection status observable\n     *\n     * @return {YoMoClientConnectionStatusObserver}\n     */\n    connectionStatus(): YoMoClientConnectionStatusObserver {\n        return this.connectionStatus$.pipe(distinctUntilChanged());\n    }\n\n    /**\n     * function that handle events given from the server\n     *\n     * @param event name of the event\n     * @param cb is the function executed if event matches the response from the server\n     */\n    on(event: string | 'close', cb: (data?: any) => void): void {\n        this.pipe(\n            filter((message: any): boolean => {\n                return (\n                    message.event &&\n                    message.event !== 'close' &&\n                    message.event === event &&\n                    message.data\n                );\n            })\n        ).subscribe({\n            next: (message: WebSocketMessage): void => cb(message.data),\n            error: () => undefined,\n            complete: (): void => {\n                event === 'close' && cb();\n            },\n        });\n    }\n\n    /**\n     * function for sending data to the server\n     *\n     * @param event name of the event\n     * @param data request data\n     */\n    emit(event: string, data: object | string): void {\n        this.socket$ && this.socket$.next({ event, data });\n    }\n\n    /**\n     * Close subscriptions, clean up.\n     */\n    close(): void {\n        this.clearSocket();\n    }\n\n    /**\n     * connect.\n     *\n     * @param url - the url of the socket server to connect to\n     * @param {YoMoClientOption} option - connect-related configuration\n     *\n     * @private\n     */\n    private async connect(url: string, option: YoMoClientOption) {\n        if (!this.wasmLoaded) {\n            try {\n                await loadWasm('https://d1lxb757x1h2rw.cloudfront.net/y3.wasm');\n                this.wasmLoaded = true;\n            } catch (error) {\n                throw error;\n            }\n        }\n\n        const tag = 0x11;\n\n        const serializer = (data: any) => {\n            return (window as any).encode(tag, data).buffer;\n        };\n\n        const deserializer = (event: MessageEvent) => {\n            const uint8buf = new Uint8Array(event.data);\n            return (window as any).decode(tag, uint8buf);\n        };\n\n        this.socket$ = new WebSocketSubject({\n            url,\n            serializer,\n            deserializer,\n            binaryType: 'arraybuffer',\n            openObserver: {\n                next: () => {\n                    this.connectionStatus$.next(true);\n                },\n            },\n            closeObserver: {\n                next: () => {\n                    this.clearSocket();\n                    this.connectionStatus$.next(false);\n                },\n            },\n        });\n\n        this.socketSubscription = this.socket$.subscribe({\n            next: (msg: any) => {\n                this.next(msg);\n            },\n            error: () => {\n                if (!this.socket$) {\n                    this.clearReconnection();\n                    this.reconnect(url, option);\n                }\n            },\n        });\n    }\n\n    /**\n     * reconnect.\n     *\n     * @param url - the url of the socket server to connect to\n     * @param {YoMoClientOption} option - reconnection-related configuration\n     *\n     * @private\n     */\n    private reconnect(url: string, option: YoMoClientOption): void {\n        this.reconnectionObservable = interval(this.reconnectInterval).pipe(\n            takeWhile(\n                (_, index) => index < this.reconnectAttempts && !this.socket$\n            )\n        );\n\n        this.reconnectionSubscription = this.reconnectionObservable.subscribe({\n            next: () => this.connect(url, option),\n            error: () => undefined,\n            complete: () => {\n                this.clearReconnection();\n                if (!this.socket$) {\n                    this.complete();\n                    this.connectionStatus$.complete();\n                }\n            },\n        });\n    }\n\n    /**\n     * clear socket.\n     *\n     * @private\n     */\n    private clearSocket(): void {\n        this.socketSubscription && this.socketSubscription.unsubscribe();\n        this.socket$ = undefined;\n    }\n\n    /**\n     * clear reconnect.\n     *\n     * @private\n     */\n    private clearReconnection(): void {\n        this.reconnectionSubscription &&\n            this.reconnectionSubscription.unsubscribe();\n        this.reconnectionObservable = undefined;\n    }\n}\n\n/**\n * check if the URL scheme is 'ws' or 'wss'\n *\n * @param protocol - URL's scheme\n */\nfunction isWSProtocol(protocol: string): boolean {\n    return protocol === 'ws' || protocol === 'wss';\n}\n\n/**\n * get URL's scheme\n *\n * @param url - the url of the socket server to connect to\n */\nfunction getProtocol(url: string) {\n    if (!url) {\n        return '';\n    }\n\n    return url.split(':')[0];\n}\n\n/**\n * @param {String} path wasm file path\n */\nasync function loadWasm(path: RequestInfo): Promise<void> {\n    // This is a polyfill for FireFox and Safari\n    if (!WebAssembly.instantiateStreaming) {\n        WebAssembly.instantiateStreaming = async (resp, importObject) => {\n            const source = await (await resp).arrayBuffer();\n            return await WebAssembly.instantiate(source, importObject);\n        };\n    }\n\n    const go = new Go();\n\n    go.importObject.env['syscall/js.finalizeRef'] = () => {};\n\n    try {\n        const result = await WebAssembly.instantiateStreaming(\n            fetch(path),\n            go.importObject\n        );\n\n        go.run(result.instance);\n    } catch (error) {\n        return Promise.reject(error);\n    }\n}\n"],"names":["runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","global","window","require","fs","enosys","code","outputBuf","constants","O_WRONLY","O_RDWR","O_CREAT","O_TRUNC","O_APPEND","O_EXCL","writeSync","fd","buf","nl","decoder","decode","lastIndexOf","console","log","substr","write","offset","position","callback","chmod","path","mode","chown","uid","gid","close","fchmod","fchown","fstat","fsync","ftruncate","lchown","link","lstat","mkdir","perm","open","flags","read","buffer","readdir","readlink","rename","from","to","rmdir","stat","symlink","truncate","unlink","utimes","atime","mtime","process","getuid","getgid","geteuid","getegid","getgroups","pid","ppid","umask","cwd","chdir","crypto","nodeCrypto","getRandomValues","b","randomFillSync","performance","now","hrtime","TextEncoder","TextDecoder","encoder","logLine","Go","_callbackTimeouts","Map","_nextCallbackTimeoutID","mem","DataView","_this","_inst","memory","setInt64","addr","v","setUint32","Math","floor","loadValue","f","getFloat64","id","getUint32","_values","storeValue","setFloat64","_ids","get","_idPool","_goRefCounts","set","typeFlag","loadSlice","array","len","cap","Uint8Array","loadSliceOfValues","a","Array","loadString","ptr","timeOrigin","Date","importObject","wasi_snapshot_preview1","fd_write","iovs_ptr","iovs_len","nwritten_ptr","nwritten","iovs_i","iov_ptr","c","getUint8","line","fd_close","fd_fdstat_get","fd_seek","proc_exit","exit","random_get","bufPtr","bufLen","env","timeout","setTimeout","go_scheduler","sp","ret_ptr","value_ptr","value_len","s","retval","v_addr","p_ptr","p_len","prop","Reflect","x_addr","p","x","deleteProperty","ret_addr","m_ptr","m_len","args_ptr","args_len","args_cap","args","m","apply","setUint8","construct","String","str","encode","slice_ptr","slice_len","slice_cap","t_addr","dest_addr","dest_len","dest_cap","source_addr","num_bytes_copied_addr","returned_status_addr","dst","src","toCopy","subarray","source_len","source_cap","run","instance","NaN","exited","callbackPromise","_this2","_resolveCallbackPromise","_start","_resume","resume","_resolveExitPromise","_makeFuncWrapper","go","event","arguments","_pendingEvent","main","versions","electron","argv","WebAssembly","instantiate","readFileSync","loadWasm","instantiateStreaming","resp","arrayBuffer","source","fetch","url","option","protocol","split","getProtocol","reconnectInterval","reconnectAttempts","connectionStatus$","Subject","subscribe","isConnected","reconnectionObservable","reconnect","wasmLoaded","connect","connectionStatus","pipe","distinctUntilChanged","on","cb","filter","message","data","emit","socket$","clearSocket","WebSocketSubject","serializer","deserializer","uint8buf","binaryType","openObserver","closeObserver","socketSubscription","msg","clearReconnection","interval","takeWhile","_","index","_this3","reconnectionSubscription","unsubscribe"],"mappings":"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"}